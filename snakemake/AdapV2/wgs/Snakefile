include: "../Snakefile"
TRUTH_BCF= config['bcf']
EAVL_REGION_BED= config['region_bed']
EVAL_REGION_IL= config['region_interval_list']
DBSNP= config['dbsnp']

rule all:
    input:
        expand(ACCU_OUT + "/{index}.error_metrics.txt", index = sample_names),
         #expand(Metrics_OUT + "/{index}.raw.insert_size_metrics.txt",index = sample_names),
         #expand(Metrics_OUT + "/byproduct/{batch_id}.{index}.byproduct.txt", zip, batch_id = metadata.reset_index()['batch'], index = metadata.reset_index()['sample']),
         #expand(Metrics_OUT + "/{index}.{type}.wgs_metrics.txt",index = sample_names, type=['cds_consensus', 'raw', 'cds_consensus.mol_consensus'])

rule CollectRawWgsMetrics:
    input:
         bam = "tmp/{index}.raw.replacerg.markdup.bam",
    output:
          metrics = Metrics_OUT + "/{index}.raw.wgs_metrics.txt",
    params:
          ref = REF,
          itl = EVAL_REGION_IL
    shell:
         """
         {PICARD} CollectWgsMetrics I={input.bam} O={output.metrics} R={params.ref} INTERVALS={params.itl} INCLUDE_BQ_HISTOGRAM=true
         """

rule CollectWgsMetrics:
    input:
         bam = "consensus/{index}.cds_consensus.replacerg.markdup.bam",
    output:
          metrics = Metrics_OUT + "/{index}.cds_consensus.wgs_metrics.txt",
    params:
          ref = REF,
          itl = EVAL_REGION_IL
    shell:
         """
         {PICARD} CollectWgsMetrics I={input.bam} O={output.metrics} R={params.ref} INTERVALS={params.itl} INCLUDE_BQ_HISTOGRAM=true
         """

rule CollectFinalWgsMetrics:
    input:
         bam = "consensus/{index}.cds_consensus.mol_consensus.aligned.bam",
    output:
          metrics = Metrics_OUT + "/{index}.cds_consensus.mol_consensus.wgs_metrics.txt",
    params:
          ref = REF,
          itl = EVAL_REGION_IL
    shell:
         """
         {PICARD} CollectWgsMetrics I={input.bam} O={output.metrics} R={params.ref} INTERVALS={params.itl} INCLUDE_BQ_HISTOGRAM=true MINIMUM_BASE_QUALITY=30
         """

rule CDSErrorMetrics:
    input:
         bam = "consensus/{index}.cds_consensus.mol_consensus.aligned.bam",
    output:
          accu = ACCU_OUT + "/{index}.error_metrics.txt",
          error = ACCU_OUT + "/{index}.mutant_families.txt",
          context = ACCU_OUT + "/{index}.context_count.txt",
    params:
          ref = REF,
          high_conf_region = EAVL_REGION_BED,
          dbsnp = DBSNP,
          germ_vcf = lambda wildcards : sample_to_vcf.loc[wildcards.index]['germline_vcf'],
          germ_bam = lambda wildcards : sample_to_germbam.loc[wildcards.index]['germline_bam'],
    resources:
             mem = 8,
             runtime = 96
    shell:
         """
            {ACCU_BIN}  -b {input.bam} \
                -L {params.high_conf_region} \
                -r {params.ref} \
                -n {params.germ_bam} \
                -m 60 \
                -q 30 \
                -d 12 \
                -V {params.germ_vcf},{params.dbsnp} \
                -x 2 \
                -c 3 \
                -5 \
                -g 30 \
                -G 250 \
                -Q 0.7 \
                -N 0.03 \
                -B 0.5 \
                -Y 20 \
                -a {output.accu} \
                -e {output.error} \
                -C {output.context}
         """

# rule Codec2Maf:
#     input:
#         ACCU_OUT + "/{index}.mutant_families.txt",
#     output:
#         temp("tmp/{index}.tmp.maf")
#     shell:
#         """
#         {CODEC2MAF} {input} {output}\
#         """

# rule Maf2Vcf:
#     input:
#         "tmp/{index}.tmp.maf"
#     output:
#         temp("tmp/{index}.tmp.vcf")
#     params:
#           ref = REF,
#     shell:
#         """
#         perl /xchip/bloodbiopsy/ruolin/apps/vcf2maf-1.6.21/maf2vcf.pl --input-maf {input} --output-dir tmp --ref-fasta {params.ref}
#         """

# rule AlignmentFilter:
#     input:
#          vcf = "tmp/{index}.tmp.vcf",
#          bam = "consensus/{index}.cds_consensus.mol_consensus.aligned.bam",
#     params:
#         bwa_index_bundle = "/xchip/bloodbiopsy/ruolin/database/gatk/hg19/Homo_sapiens_assembly19.fasta.img",
#         ref = REF,
#     output:
#         vcf = temp(ACCU_OUT + "/{index}.mutant_families.alignment_filtered.vcf"),
#         idx = temp(ACCU_OUT + "/{index}.mutant_families.alignment_filtered.vcf.idx"),
#     shell:
#         """
#         {GATK} FilterAlignmentArtifacts -R {params.ref} -V {input.vcf} -I {input.bam} --bwa-mem-index-image {params.bwa_index_bundle} -O {output.vcf}
#         """

# rule Vcf2Maf:
#     input:
#           ACCU_OUT + "/{index}.mutant_families.alignment_filtered.vcf"
#     output:
#           ACCU_OUT + "/{index}.snv.alignment_filtered.maf",
#           temp(ACCU_OUT + "/{index}.mutant_families.alignment_filtered.vep.vcf")
#     params:
#         vep = "/xchip/bloodbiopsy/ruolin/apps/ensembl-vep",
#         ref = REF,
#     shell:
#         """
#         perl /xchip/bloodbiopsy/ruolin/apps/vcf2maf-1.6.21/vcf2maf.pl --input-vcf {input} --output-maf {output} \
#             --vep-path {params.vep} --vep-data {params.vep} --ref-fasta {params.ref} --vcf-normal-id NORMAL \
#             --vcf-tumor-id TUMOR
#         """
# rule UpdateErrorMetrics:
#     input:
#          error = ACCU_OUT + "/{index}.mutant_families.txt",
#          accu = ACCU_OUT + "/{index}.error_metrics.txt",
#          maf = ACCU_OUT + "/{index}.snv.alignment_filtered.maf",
#     output:
#         ACCU_OUT + "/{index}.done"
#     shell:
#         """
#         {UPDATE_MET} {input.accu} {input.error} {input.maf} && echo done > {output}
#         """

# rule RawErrorMetrics:
#     input:
#          bam = "tmp/{sample_id}.{index}.raw.aligned.bam",
#     output:
#           accu = ACCU_OUT + "/raw/{sample_id}.{index}.error_metrics.txt",
#           error = ACCU_OUT + "/raw/{sample_id}.{index}.mutant_families.txt",
#           known = ACCU_OUT + "/raw/{sample_id}.{index}.known_var.txt",
#           readlevel = ACCU_OUT + "/raw/{sample_id}.{index}.readlevel.txt",
#     params:
#           ref = REF,
#           mapq = 60,
#           baseq = 0,
#           high_conf_region = EAVL_REGION_BED,
#           germ_vcf = TRUTH_BCF,
#           vcf_sid = "HG001"
#     resources:
#              mem = 8,
#              runtime = 96
#     shell:
#          """
#             {ACCU_BIN}  -b {input.bam} \
#                 -L {params.high_conf_region} \
#                 -m {params.mapq} \
#                 -r {params.ref} \
#                 -V {params.germ_vcf} \
#                 -s {params.vcf_sid} \
#                 -p 50 \
#                 -O \
#                 -q {params.baseq} \
#                 -a {output.accu} \
#                 -e {output.error} \
#                 -k {output.known} \
#                 --read_level_stat {output.readlevel}
#          """


#group_to_samples = metadata.reset_index().groupby('group_id').sample.agg(list)
#print(group_to_samples)
# rule MergeGroupConsensus:
#     input:
#          lambda wildcard: expand("consensus/{id}.{{index}}.consensus.aligned.bam", id = batch_ids)
#     output:
#           bam = temp("consensus/{index}.cds_consensus.aligned.bam")
#     resources:
#              mem = 8,
#              ncores = config['ncores'],
#              runtime = 16,
#     shell:
#          """
#          samtools merge -@ {resources.ncores} {output.bam} {input}
#          """

# rule MergeAll:
#     input:
#          expand("consensus/{index}.cds_consensus.aligned.bam", index=metadata.index.unique())
#     output:
#          bam = temp("consensus/{all}.cds_consensus.tmp.bam")
#     resources:
#              mem = 8,
#              ncores = config['ncores'],
#              runtime = 16,
#     shell:
#          """
#          samtools merge -@ {resources.ncores} {output.bam} {input} && samtools index {output.bam}
#          """


# rule DeepTools:
#     input:
#          bam = "consensus/{merged_id}.merged.cds_consensus.mol_consensus.aligned.bam",
#     output:
#          met =  Metrics_OUT + "/{merged_id}.covmetrics.txt",
#          plot = Metrics_OUT + "/{merged_id}.covplot.png"
#     params:
#           high_conf_region = EAVL_REGION_BED,
#     resources:
#           mem = 48,
#           runtime = 24,
#     shell:
#         """
#         plotCoverage -b {input.bam} -o {output.plot} --outCoverageMetrics {output.met} -ct 1 -ct 2 -ct 3 -ct 4 -ct 5 -ct 6 -ct 7 -ct 8 -ct 9 -ct 10 --BED {params.high_conf_region}
#         """

# rule SamDepth:
#     input:
#         bam = "consensus/{merged_id}.merged.cds_consensus.mol_consensus.aligned.bam",
#     output:
#         Metrics_OUT + "/{merged_id}_merged.cds_consensus.mol_consensus.covmetric.txt"
#     resources:
#        mem = 8,
#        runtime = 24,
#        ncores = config['ncores']
#     params:
#        high_conf_region = EAVL_REGION_BED,
#     shell:
#         """
#         sambamba depth base {input} \
#             -L {params.high_conf_region} \
#             --min-coverage=0 \
#             --min-base-quality=30 \
#             -t {resources.ncores} \
#             -F "mapping_quality >= 30" \
#             -m \
#             --combined 2>/dev/null \
#             | cut -f 1-3 \
#             | ../../../script/cov_sum.py > {output}
#         """
# rule CollectAlignmentSummaryMetrics:
#     input:
#          bam = "tmp/{id}.cds.raw.aligned.bam"
#     output:
#           metrics = Metrics_OUT + "/{id}.cds.raw.alignment_metrics.txt",
#     params:
#           ref = REF
#     shell:
#          """
#          {PICARD} CollectAlignmentSummaryMetrics I={input.bam} O={output.metrics} R={params.ref}
#          """

# rule CollectInsertSizeMetrics:
#     input:
#          bam = "consensus/{merged_id}.merged.consensus.mol_consensus.aligned.bam",
#     output:
#           txt = Metrics_OUT + "/{merged_id}_merged.raw.insert_size_metrics.txt",
#           hist = Metrics_OUT + "/{merged_id}_merged.raw.insert_size_histogram.pdf"
#     shell:
#          """
#          {PICARD} CollectInsertSizeMetrics I={input.bam} O={output.txt} H={output.hist} M=0.5 W=600 DEVIATIONS=100
#          """